Configuration and command line parser
=====================================

Libucw contains a parser for configuration files described in
<<config:>>.

The principle is you specify the structure of the configuration file,
the section names, variable names and types and your C variables that
are assigned to them. Then you run the parser and it fills your
variables with the values from the configuration file.

It is modular. It means you do not have to write all configuration at
the same place, you just declare the parts you need locally and do not
care about the other parts.

The command line parser has the same interface as unix getopt_long,
but handles setting of configuration files and configuration values
from command line.

- <<example,Example>>
  * <<ex_structure,The structure>>
  * <<ex_load,Loading>>
- <<deep,Getting deeper>>
  * <<reload,Reloading configuration>>
  * <<custom_parser,Creating custom parsers>>
  * <<hooks,Hooks>>
- <<conf_h,ucw/conf.h>>
  * <<conf_types,Data types>>
  * <<conf_macros,Convenience macros>>
  * <<alloc,Memory allocation>>
  * <<journal,Undo journal>>
  * <<bparser,Parsers for basic types>>
- <<getopt_h,ucw/getopt.h>>
  * <<conf_load,Safe configuration loading>>
  * <<conf_direct,Direct access>>
  * <<conf_dump,Debug dumping>>
  * <<conf_journal,Journaling control>>
  * <<conf_getopt,Loading by cf_getopt()>>

[[example]]
Example
-------
If you want to just load simple configuration, this is the part you
want to read. This simple example should give you the overview. Look
into the <<conf_macros,convenience macros>> section to see list of
supported data types, sections, etc.

[[ex_cfile]]
Let's say you have configuration file with this content and want to
load it:

  HelloWorld {
    Text	"Hello planet"
    Count	3
  }

[[ex_structure]]
The structure
~~~~~~~~~~~~~
First, you declare the structure and let the configuration parser know
it exists.

  #include <ucw/lib.h>
  #include <ucw/conf.h>

  static char *hw_text = "Hello world";
  static int hw_count = 1;
  static int hw_wait_answer = 0;

  static struct cf_section hw_config = {
    CF_ITEMS {
      CF_STRING("Text", &hw_text),
      CF_INT("Count", &hw_count),
      CF_INT("WaitAnswer", &hw_wait_answer),
      CF_END
    }
  };

  static void CONSTRUCTOR hw_init(void) {
    cf_declare_section("HelloWorld", &hw_config, 0);
  }

The variables are used to store the loaded values. Their initial
values work as default, if nothing else is loaded. The hw_config()
structure assigns the variables to configuration names. The hw_init()
function (because of the `CONSTRUCTOR` macro) is run before main()
is called and it plugs in the whole section to the parser.

You can plug in as many configuration sections as you like, from
various places across your code.

[[ex_load]]
Loading of the values
~~~~~~~~~~~~~~~~~~~~~
You need to parse the command line arguments and load the
configuration. You can do it in a similar way to this example.

  #include <ucw/lib.h>
  #include <ucw/conf.h>
  #include <ucw/getopt.h>

  static byte short_opts[] = CF_SHORT_OPTS "v";
  static struct option long_opts[] = {
    CF_LONG_OPTS
    { "verbose", 0, 0, 'v' },
    { NULL, 0, 0, 0 }
  };

  int verbose;

  int main(int argc, char *argv[]) {
    cf_def_file = "default.cf";
    int opt;
    while((opt = cf_getopt(argc, argv, short_opts, long_opts, NULL)) >= 0)
      switch(opt) {
	case 'v': verbose = 1; break;
	default: fprintf("Unknown option %c\n", opt); return 1;
      }

The `short_opts` and `long_opts` variables describe the command line
arguments. Notice the `CF_SHORT_OPTS` and `CF_LONG_OPTS` macros. They
add options for the configuration parser. These options are handled
internally by @cf_getopt(). It loads the configuration before it starts
giving you your program's options.

See documentation of unix getopt_long() function.

[[deep]]
Getting deeper
--------------

Since the configuration system is somehow complicated, this part gives
you a little overview of what you can find and where.

[[reload]]
Reloading configuration
~~~~~~~~~~~~~~~~~~~~~~~

The configuration system allows you to reload configuration at
runtime. The new config changes the values against the default values.
It means, if the default value for variable `A` is `10`, the currently
loaded config sets it to `42` and the new config does not talk about
this variable, `A` will have a value of `10` after a successful load.

Furthermore, if the loading of a new configuration fails, the current
configuration is preserved.

All this is done with <<journal,config journaling>>. The load of the
first config creates a journal entry. If you try to load some new
configuration, it is partially rolled back to defaults (the rollback
happens, but instead of removing the journal entry, another journal
entry is added for the rollback). If the loading succeeds, the two
journal entries are removed and a new one, for the new configuration,
is added. If it fails, the first one is replayed and the rollback
entry is removed.

See <<cf_reload()>>.

[[custom_parser]]
Creating custom parsers
~~~~~~~~~~~~~~~~~~~~~~~

If you need to parse some data type the configuration system can't
handle, you can write your own parser. But before you start, you
should know few thinks.

The parser needs to support <<journal,journaling>>. To accomplish that,
you have to use the <<alloc,configuration mempool>> for memory allocation.
Furthermore, you need to call @cf_journal_block() before you change
the configuration (eg. before you save the parsed value to the destination
variable). You can use <<def_CF_JOURNAL_VAR,`CF_JOURNAL_VAR`>> macro
instead if it is simple variable.

Now, you need a function with the same signature as
<<type_cf_parser1,`cf_parser1`>>. Parse the first parameter (the
string), call @cf_journal_block() on the second parameter and store
the data there. You may want to write a dumper function, with
signature of <<type_cf_dumper1,`cf_dumper1`>> (needed for debug
dumps).

// TODO Does the config system support storing of configuration?

Fill in a <<struct_cf_user_type,structure cf_user_type>> and use the
new data type in your configuration description with
<<def_CF_USER,`CF_USER` macro>>.

[[hooks]]
Hooks
~~~~~

The configuration system supports hooks. They are used to initiate the
configuration (if simple default value of variable is not enough) and
to check the sanity of loaded data.

Each hook is of type <<type_cf_hook,`cf_hook`>> and you can include
them in configuration description using <<def_CF_INIT,`CF_INIT`>> and
<<def_CF_COMMIT,`CF_COMMIT`>> macros.

The hooks should follow similar guidelines as custom parsers (well,
init hooks do not need to call @cf_journal_block()) to support
journaling. If you change nothing in the commit hook, you do not need
to care about the journaling either.

// TODO maybe copier here too? What good is it?

[[conf_h]]
ucw/conf.h
----------

Use this file if you want define a configuration section, request
loading of some variables or create new item type.

!!ucw/conf.h

[[getopt_h]]
ucw/getopt.h
------------

This header contains routines for parsing command line arguments and
loading the configuration.

!!ucw/getopt.h
