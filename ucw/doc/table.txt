Table printer
=============

The table printer module provides formatting of 2-dimensional tables
in various ways.

Each table consists of a number of rows, which are processed one
after another. All rows have the same number of columns. Internally,
the columns have a fixed order, each column has its name and a data
type (e.g., int, uint, u64, etc.). The table printer checks that
each cell is filled by a value of the appropriate type, except that
a string value is allowed in any cell (for example, this allows
a numeric cell to be set to "--" or "unknown").

Once a table is defined, it can be printed using a variety of formatters
(human-readable, tab-separated values, etc.). Also, a subset of columns
can be selected and their order changed.

Example
-------

Let us construct a simple table of music recordings:

First, we define an enum with column indices (the values are automatically
numbered starting from 0):

  // Definition of columns
  enum table_columns {
     TBL_REC_ID,
     TBL_REC_ALBUM_NAME,
     TBL_REC_ARTIST,
     TBL_REC_YEAR
  };

Then we create a structure with the definition of our table.
The table columns are defined using the `TBL_COL_xxx` and `TBL_COL_xxx_FMT`
macros. Each macro gets the name of the column and its default width
in character. The `_FMT` version has an additional argument: the format
string for `printf` used for this column. Moreover, various flags can
be OR-ed to the width of the column, for example `CELL_ALIGN_LEFT` prescribes
that the cell should be aligned to the left.

  struct table recording_table = {
    TBL_COLUMNS {
       [TBL_REC_ID] = TBL_COL_UINT("id", 16),
       [TBL_REC_ALBUM_NAME] = TBL_COL_STR_FMT("album-name", 20 | CELL_ALIGN_LEFT, "%s"),
       [TBL_REC_ARTIST] = TBL_COL_STR("artist", 20),
       [TBL_REC_YEAR] = TBL_COL_UINT("year", 10),
       TBL_COL_END
    }
  };

Before you use the table definition, you need to initialize it:

  table_init(&recording_table);

With a single definition, you can print multiple tables. At the start
of each table, you should obtain a <<fastbuf:,fastbuf>> where the output
should be sent, store it in the table structure and call table_start():

  struct fastbuf *out = bfdopen_shared(1, 4096);
  table_start(&recording_table, out);

Then you can fill the rows one after another. Each row is ended by
table_end_row():

  table_col_uint(&recording_table, TBL_REC_ID, 0);
  table_col_str(&recording_table, TBL_REC_ALBUM_NAME, "The Wall");
  table_col_str(&recording_table, TBL_REC_ARTIST, "Pink Floyd");
  table_col_uint(&recording_table, TBL_REC_YEAR, 1979);
  table_end_row(&recording_table);

  table_col_uint(&recording_table, TBL_REC_ID, 1);
  table_col_str(&recording_table, TBL_REC_ALBUM_NAME, "Rio Grande Mud");
  table_col_str(&recording_table, TBL_REC_ARTIST, "ZZ Top");
  table_col_uint(&recording_table, TBL_REC_YEAR, 1972);
  table_end_row(&recording_table);

Finally, you should close the table by calling table_end():

  table_end(&recording_table);

At this moment, the table structure is ready to be used again. When
you do not need it any longer, you can dispose of it by table_cleanup():

  table_cleanup(&recording_table);

ucw/table.h
-----------

!!ucw/table.h
