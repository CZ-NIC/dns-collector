# Automatic configuration of the UCW Library
# (c) 2005 Martin Mares <mj@ucw.cz>

### OS ###

Test("OS", "Checking on which OS we run", sub {
	my $os = `uname`;
	chomp $os;
	Fail "Unable to determine OS type" if $? || $os eq "";
	return $os;
});

if (Get("OS") eq "Linux") {
	Set("CONFIG_LINUX");
} else {
	Fail "Don't know how to run on this operating system.";
}

### Compiler ###

# Default compiler
Test("CC", "Checking for C compiler", sub { return "gcc"; });

# GCC version
Test("GCCVER", "Checking for GCC version", sub {
	my $gcc = Get("CC");
	my $ver = `$gcc --version | sed '2,\$d; s/^\\(.* \\)\\?\\([0-9]*\\.[0-9]*\\).*/\\2/'`;
	chomp $ver;
	Fail "Unable to determine GCC version" if $? || $ver eq "";
	return $ver;
});
my ($gccmaj, $gccmin) = split(/\./, Get("GCCVER"));
my $gccver = 1000*$gccmaj + $gccmin;
$gccver >= 3000 or Fail "GCC older than 3.0 doesn't support C99 well enough.";

### CPU ###

Test("ARCH", "Checking for machine architecture", sub {
	my $mach = `uname -m`;
	chomp $mach;
	Fail "Unable to determine machine type" if $? || $mach eq "";
	if ($mach =~ /^i[0-9]86$/) {
		return "i386";
	} elsif ($mach =~ /^(x86[_-]|amd)64$/) {
		return "amd64";
	} else {
		return "unknown";
	}
});

Test("CPU_ARCH", "Checking for CPU architecture", sub {
	my $mach = Get("ARCH");
	if ($mach eq "i386") {
		Set("CPU_I386");
		UnSet("CPU_64BIT_POINTERS");
		Set("CPU_LITTLE_ENDIAN");
		UnSet("CPU_BIG_ENDIAN");
		Set("CPU_ALLOW_UNALIGNED");
		Set("CPU_STRUCT_ALIGN" => 4);
		my $arch = "";
		if (IsSet("CONFIG_EXACT_CPU") && IsSet("CONFIG_LINUX") && open X, "/proc/cpuinfo") {
			my %pc = ();
			while (<X>) {
				chomp;
				/^$/ && last;
				/^([^\t]+)\t+:\s*(.*)$/ and $pc{$1}=$2;
			}
			close X;

			# Try to understand CPU vendor, family and model [inspired by MPlayer's configure script]
			my $vendor = $pc{'vendor_id'} || "";
			my $family = $pc{'cpu family'} || 0;
			my $model  = $pc{'model'} || 0;
			if ($vendor eq "AuthenticAMD") {
				if ($family >= 6) {
					if ($model >= 31 && $gccver >= 3004) { $arch = "athlon64"; }
					elsif ($model >= 6 && $gccver >= 3003) { $arch = "athlon-xp"; }
					else { $arch = "athlon"; }
				}
			} elsif ($vendor eq "GenuineIntel") {
				# We don't recognize Prescott and Nocona cores yet (gcc-3.4+)
				if ($family >= 15 && $gccver >= 3003) { $arch = "pentium4"; }
				elsif ($family >= 6 && $gccver >= 3003) {
					if ($model >= 7) { $arch = "pentium3"; }
					elsif ($model >= 3) { $arch = "pentium2"; }
				}
			}

			# No match on vendor, try the family
			if ($arch eq "") {
				if ($family >= 6) {
					$arch = "i686";
				} elsif ($family >= 3) {
					$arch = "i${family}86";
				}
			}
			if ($arch ne "") {
				Log "(using /proc/cpuinfo) ";
			} else {
				Log "(don't understand /proc/cpuinfo) ";
			}
		}
		return $arch ? $arch : "i386";
	} elsif ($mach eq "amd64") {
		Set("CPU_AMD64");
		Set("CPU_64BIT_POINTERS");
		Set("CPU_LITTLE_ENDIAN");
		UnSet("CPU_BIG_ENDIAN");
		Set("CPU_ALLOW_UNALIGNED");
		Set("CPU_STRUCT_ALIGN" => 8);
		return "x86-64";
	} else {
		return undef;
	}
});

if (!IsSet("CPU_ARCH")) { Warn "CPU type not recognized, using defaults, keep fingers crossed."; }

### Compiler and its Options ###

# C flags: tell the compiler we're speaking C99
Set("CLANG" => "-std=gnu99");

# C optimizations
Set("COPT" => '-O2');
Append("COPT", '-march=$(CPU_ARCH)') if IsSet("CPU_ARCH");

# C optimizations for highly exposed code
Set("COPT2" => '-O3');

# Warnings
Set("CWARNS" => '-Wall -W -Wno-parentheses -Wstrict-prototypes -Wmissing-prototypes -Winline');
Set("CWARNS_OFF" => '');

# Linker flags
Set("LOPT" => "");

# Extra libraries
Set("LIBS" => "");

# Extra flags for compiling and linking shared libraries
Set("CSHARED" => '-fPIC');
Set("LSHARED" => '-shared -Wl,-soname,lib/$(@F)');

# Extra switches depending on GCC version:
if ($gccver == 3000) {
	Append("COPT" => "-fstrict-aliasing");
} elsif ($gccver == 3003) {
	Append("CWARNS" => "-Wundef -Wredundant-decls");
	Append("COPT" => "-finline-limit=20000 --param max-inline-insns-auto=1000");
} elsif ($gccver == 3004) {
	Append("CWARNS" => "-Wundef -Wredundant-decls");
	Append("COPT" => "-finline-limit=2000 --param large-function-insns=5000 --param inline-unit-growth=200 --param large-function-growth=400");
} elsif ($gccver == 4000 || $gccver == 4001) {
	Append("CWARNS" => "-Wundef -Wredundant-decls -Wno-pointer-sign -Wdisabled-optimization -Wno-missing-field-initializers");
	Append("CWARNS_OFF" => "-Wno-pointer-sign");
	Append("COPT" => "-finline-limit=5000 --param large-function-insns=5000 --param inline-unit-growth=200 --param large-function-growth=400");
} else {
	Warn "Don't know anything about this GCC version, using default switches.\n";
}

if (IsSet("CONFIG_DEBUG")) {
	# If debugging:
	Set("DEBUG_ASSERTS");
	Set("DEBUG_DIE_BY_ABORT") if Get("CONFIG_DEBUG") > 1;
	Set("CDEBUG" => "-ggdb");
	Set("COPT" => "");
	Set("COPT2" => "");
} else {
	# If building a release version:
	Append("COPT" => "-fomit-frame-pointer");
	Append("LOPT" => "-s");
}

# Decide how will lib/partmap.c work
Set("PARTMAP_IS_MMAP") if IsSet("CPU_64BIT_POINTERS");

# If debugging memory allocations:
#LIBS+=-lefence
#CDEBUG+=-DDEBUG_DMALLOC
#LIBS+=-ldmalloc

# Return success
1;
